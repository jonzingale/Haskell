module Tournament where
-- :set +s

{--
The idea here is to show that the graph generated by way
of Havel-Hakimi balances rank fairly well. By counting
the total rank each player is expect to face, we can
see a fairly small variance.
--}

type Edge = (Int, Int)
type Vertex = Int
type Degree = Int

list :: [Edge]
list = [(10,9),(10,8),(10,7),(10,6),(10,5),(10,4),(10,3),(2,1),(2,9),(2,8),
        (2,7),(2,6),(2,5),(2,4),(3,1),(3,9),(3,8),(3,7),(3,6),(3,5),(4,1),
        (4,9),(4,8),(4,7),(4,6),(5,1),(5,9),(5,8),(5,7),(6,1),(6,9),(6,8),
        (7,1),(7,9),(8,1)]

avgs :: [Edge] -> [(Vertex, Int)]
avgs [] = []
avgs edges = let biggie = maximum.flatten $ edges in
  [(n, countem n edges) | n<-[1..biggie]]
  where
    flatten [] = []
    flatten ((u,v):xs) = u : v : flatten xs

countem n [] = 0
countem n ((u,v):xs) | u == n = v + countem n xs
                     | v == n = u + countem n xs
                     | otherwise = countem n xs

pair_to_var :: [Edge] -> Int
pair_to_var edges = let vals = map snd $ avgs list in
  foldr (+) 0 [((avg vals) - x)^2 | x<-vals] `div` length vals
  where
    avg list = foldr (+) 0 list `div` (length list)

standard_dev :: [Edge] -> Float -- ~ 4
standard_dev pair_list = sqrt.fromIntegral.pair_to_var $ pair_list